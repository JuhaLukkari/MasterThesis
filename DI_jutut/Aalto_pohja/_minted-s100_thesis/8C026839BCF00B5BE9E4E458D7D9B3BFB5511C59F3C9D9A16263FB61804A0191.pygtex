\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{socket}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{signal}
\PYG{k+kn}{import} \PYG{n+nn}{subprocess}
\PYG{k+kn}{import} \PYG{n+nn}{thread}
\PYG{k+kn}{import} \PYG{n+nn}{time}
\PYG{k+kn}{from} \PYG{n+nn}{fcntl} \PYG{k+kn}{import} \PYG{n}{fcntl}\PYG{p}{,} \PYG{n}{F\PYGZus{}GETFL}\PYG{p}{,} \PYG{n}{F\PYGZus{}SETFL}
\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{,} \PYG{n}{read}
\PYG{k+kn}{from} \PYG{n+nn}{ConfigParser} \PYG{k+kn}{import} \PYG{n}{SafeConfigParser}
\PYG{k+kn}{import} \PYG{n+nn}{psutil}
\PYG{k+kn}{import} \PYG{n+nn}{robot}
\PYG{k+kn}{import} \PYG{n+nn}{paramiko}

\PYG{k}{class} \PYG{n+nc}{CubeSatAutomation}\PYG{p}{(}\PYG{n+nb}{object}\PYG{p}{):}
	\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Function library for CubeSat test automation}
\PYG{l+s+sd}{		Version 1.0. Written by Juha\PYGZhy{}Matti Lukkari 2017\PYGZhy{}2018.}
\PYG{l+s+sd}{		Provides low level methods to automate testing of both local terminal based programs}
\PYG{l+s+sd}{		and remote systems with networking capabilities.}
\PYG{l+s+sd}{		A local program would be e.g. groundstation software, a remote system could e.g.}
\PYG{l+s+sd}{		be a Hardware\PYGZhy{}in\PYGZhy{}the\PYGZhy{}loop, such as a satellite subsystem in a testbed.}

\PYG{l+s+sd}{		stdin/stdout of a local program is used for commanding and receiving responses}
\PYG{l+s+sd}{		from the program.}
\PYG{l+s+sd}{		Socket connection is used for commanding and receiving responses from a remote}
\PYG{l+s+sd}{		program.}
\PYG{l+s+sd}{		SSH is used to start and close programs for testing in a remote system.}

\PYG{l+s+sd}{	\PYGZsq{}\PYGZsq{}\PYGZsq{}}

	\PYG{n}{ROBOT\PYGZus{}LIBRARY\PYGZus{}SCOPE} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}TEST\PYGZus{}SUITE\PYGZsq{}}
	\PYG{n}{proc} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{server} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{0}
	\PYG{n}{sock} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{ssh} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}

	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser} \PYG{o}{=} \PYG{n}{SafeConfigParser}\PYG{p}{()}

	\PYG{k}{def} \PYG{n+nf}{connect\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{n}{port}\PYG{p}{,} \PYG{n}{config\PYGZus{}file}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{wait\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Connect to a network socket}
\PYG{l+s+sd}{			Server is either the hostname or the IP address of the host.}
\PYG{l+s+sd}{			Server and port defined in a config file override the given settings.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{config\PYGZus{}file}\PYG{p}{:}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Config file\PYGZdq{}}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{))}
			\PYG{n}{server} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}SOCKET\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}server\PYGZsq{}}\PYG{p}{))}
			\PYG{n}{port} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}SOCKET\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}port\PYGZsq{}}\PYG{p}{))}

		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{server} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{server}\PYG{p}{)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{port} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{port}\PYG{p}{)}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Opening socket connection..\PYGZdq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock} \PYG{o}{=} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{socket}\PYG{p}{(}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{AF\PYGZus{}INET}\PYG{p}{,} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{SOCK\PYGZus{}STREAM}\PYG{p}{)}
		\PYG{n}{server\PYGZus{}address} \PYG{o}{=} \PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{server}\PYG{p}{,} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{port}\PYG{p}{)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{server\PYGZus{}address}\PYG{p}{)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{setblocking}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{)} 		\PYG{c+c1}{\PYGZsh{} For non\PYGZhy{}blocking network communication}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Connected to }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ port }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{server\PYGZus{}address}
		\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{wait\PYGZus{}time}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{close\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Close the network socket}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Closing socket connection\PYGZdq{}}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{shutdown}\PYG{p}{(}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{SHUT\PYGZus{}RDWR}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock} \PYG{o}{=} \PYG{n+nb+bp}{None}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{server} \PYG{o}{=} \PYG{n+nb+bp}{None}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}No socket connection initialized!\PYGZdq{}}

	\PYG{k}{def} \PYG{n+nf}{program\PYGZus{}start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{prog}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{config\PYGZus{}file}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{wait\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Start the program for automation}
\PYG{l+s+sd}{			Program and params defined in a config file override the given settings.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{config\PYGZus{}file}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{))}
			\PYG{n}{prog} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}PROGRAM\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}path\PYGZsq{}}\PYG{p}{)}
			\PYG{n}{params} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}PROGRAM\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}params\PYGZsq{}}\PYG{p}{)}

		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Opening program }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ for automated control..\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc} \PYG{o}{=} \PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{Popen}\PYG{p}{([}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)],} \PYG{n}{stdin}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{PIPE}\PYG{p}{,}
			\PYG{n}{stdout}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{PIPE}\PYG{p}{,} \PYG{n}{stderr}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{STDOUT}\PYG{p}{,} \PYG{n}{shell}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
		\PYG{n}{flags} \PYG{o}{=} \PYG{n}{fcntl}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{,} \PYG{n}{F\PYGZus{}GETFL}\PYG{p}{)} 		\PYG{c+c1}{\PYGZsh{} get current process stdout flags}
		\PYG{n}{fcntl}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{,} \PYG{n}{F\PYGZus{}SETFL}\PYG{p}{,} \PYG{n}{flags} \PYG{o}{|} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} For non\PYGZhy{}blocking stdout communication}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Started program \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{} with parameters \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
		\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{wait\PYGZus{}time}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{program\PYGZus{}close}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Close the program we were automating}
\PYG{l+s+sd}{			Close any existing socket connections as well.}
\PYG{l+s+sd}{			First tries to close the program in a neat way, if that fails}
\PYG{l+s+sd}{			then executes the \PYGZsq{}kill\PYGZsq{} command from terminal.}

\PYG{l+s+sd}{			Any program that stays alive and doesn\PYGZsq{}t exit after tests have finished}
\PYG{l+s+sd}{			is a problem for the subsequent tests against the same program.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{close\PYGZus{}socket}\PYG{p}{()}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{p}{:}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{terminate}\PYG{p}{()} 	\PYG{c+c1}{\PYGZsh{} Doesn\PYGZsq{}t close the program properly in some cases!}
			\PYG{k}{if} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getpgid}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{):}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Clean termination of the program wasn\PYGZsq{}t successful.\PYGZdq{}}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Attempting to terminate from OS..\PYGZdq{}}
				\PYG{n}{pid} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getpgid}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{)}
				\PYG{n}{kill\PYGZus{}command} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}kill \PYGZhy{}15 \PYGZdq{}} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}\PYGZhy{}\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{pid}\PYG{p}{)}
				\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{Popen}\PYG{p}{([}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{kill\PYGZus{}command}\PYG{p}{)],} \PYG{n}{shell}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}

			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc} \PYG{o}{=} \PYG{n+nb+bp}{None}

	\PYG{k}{def} \PYG{n+nf}{remote\PYGZus{}program\PYGZus{}start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{prog}\PYG{p}{,} \PYG{n}{server}\PYG{p}{,} \PYG{n}{port}\PYG{o}{=}\PYG{l+m+mi}{22}\PYG{p}{,}
						\PYG{n}{user}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{passw}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{config\PYGZus{}file}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{wait\PYGZus{}time}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Start a program for testing at a remote location through SSH}
\PYG{l+s+sd}{			Using a config file for setup is preferred.}
\PYG{l+s+sd}{			Parameters for the program are not defined separately, but}
\PYG{l+s+sd}{			should be included to the prog argument.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{ssh} \PYG{o}{=} \PYG{n}{paramiko}\PYG{o}{.}\PYG{n}{SSHClient}\PYG{p}{()}
		\PYG{n}{ssh}\PYG{o}{.}\PYG{n}{set\PYGZus{}missing\PYGZus{}host\PYGZus{}key\PYGZus{}policy}\PYG{p}{(}\PYG{n}{paramiko}\PYG{o}{.}\PYG{n}{AutoAddPolicy}\PYG{p}{())}
		\PYG{k}{if} \PYG{n}{config\PYGZus{}file}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{))}
			\PYG{n}{prog} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}REMOTE\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}prog\PYGZsq{}}\PYG{p}{))}
			\PYG{n}{server} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}REMOTE\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}server\PYGZsq{}}\PYG{p}{))}
			\PYG{n}{port} \PYG{o}{=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}REMOTE\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}port\PYGZsq{}}\PYG{p}{))}
			\PYG{n}{user} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}REMOTE\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}username\PYGZsq{}}\PYG{p}{))}
			\PYG{n}{passw} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}REMOTE\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}password\PYGZsq{}}\PYG{p}{))}

		\PYG{n}{ssh}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{hostname}\PYG{o}{=}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{server}\PYG{p}{),} \PYG{n}{port}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{port}\PYG{p}{),} \PYG{n}{username}\PYG{o}{=}\PYG{n}{user}\PYG{p}{,} \PYG{n}{password}\PYG{o}{=}\PYG{n}{passw}\PYG{p}{)}
		\PYG{n}{stdin}\PYG{p}{,} \PYG{n}{stdout}\PYG{p}{,} \PYG{n}{stderr} \PYG{o}{=} \PYG{n}{ssh}\PYG{o}{.}\PYG{n}{exec\PYGZus{}command}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{),} \PYG{n}{get\PYGZus{}pty}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Started program }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ on remote server }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{),} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{server}\PYG{p}{))}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{ssh} \PYG{o}{=} \PYG{n}{ssh}
		\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{wait\PYGZus{}time}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{remote\PYGZus{}program\PYGZus{}close}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Close a remotely started program through SSH}
\PYG{l+s+sd}{			Simply closes the socket and as get\PYGZus{}pty was used, the program should}
\PYG{l+s+sd}{			terminate on the remote system.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{ssh}\PYG{p}{:}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{ssh}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{ssh} \PYG{o}{=} \PYG{n+nb+bp}{None}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}send\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Send message through socket connection}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Sending command \PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZsq{} through socket connection\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}
		\PYG{n}{command} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s2}{\PYGZdq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{sendall}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}send\PYGZus{}console}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Send message through standard input}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Sending command \PYGZsq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZsq{} through standard input\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}
		\PYG{n}{command} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}communicate}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Choose the communication route for sending commands}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}send\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}send\PYGZus{}console}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}receive}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Choose the communication route for receiving replies}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{p}{:}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}read\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}read\PYGZus{}console}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{k}{return} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{send\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Send commands to the program via the socket connection}
\PYG{l+s+sd}{			Replies from the socket are read concurrently.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}send\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}read\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{write\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Send commands to the program via standard input}
\PYG{l+s+sd}{			Replies from standard output are read concurrently.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}send\PYGZus{}console}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}read\PYGZus{}console}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{type\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Send commands to the program by simulating typing on a keyboard}
\PYG{l+s+sd}{			Uses pyautogui library to perform the simulated typing.}
\PYG{l+s+sd}{			Replies from standard output are read concurrently.}

\PYG{l+s+sd}{			Use this keyword with caution! When using this keyword, the computer}
\PYG{l+s+sd}{			shouldn\PYGZsq{}t be used for anything else than performing testing.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k+kn}{import} \PYG{n+nn}{pyautogui}
		\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{typewrite}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{press}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}enter\PYGZsq{}}\PYG{p}{)}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}read\PYGZus{}console}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}read\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read messages through the socket}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Reading messages from socket connection\PYGZdq{}}
		\PYG{n}{socket\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[]}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}					\PYG{c+c1}{\PYGZsh{} Wait for data to be \PYGZsq{}cooked\PYGZsq{}}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{line} \PYG{o}{=} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}
			\PYG{k}{except} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{error}\PYG{p}{:}			\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
				\PYG{n}{socket\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Waiting for more data from socket..}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
				\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
				\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{k}{try}\PYG{p}{:}
						\PYG{n}{line} \PYG{o}{=} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}
					\PYG{k}{except} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{error}\PYG{p}{:}
						\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
						\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{k}{continue}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{k}{break}
				\PYG{k}{if} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{n}{socket\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Process data read timeout!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
					\PYG{k}{break}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}sock:\PYGZdq{}} \PYG{o}{+} \PYG{n}{line}\PYG{o}{.}\PYG{n}{rstrip}\PYG{p}{()}
			\PYG{k}{if} \PYG{n}{line} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{:}
				\PYG{n}{socket\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
		\PYG{k}{return} \PYG{n}{socket\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{\PYGZus{}read\PYGZus{}console}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Read messages through standard output}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[]}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}					\PYG{c+c1}{\PYGZsh{} Wait for data to be \PYGZsq{}cooked\PYGZsq{}}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{line} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
			\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}					\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
				\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Waiting for more data from process..}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
				\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
				\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{k}{try}\PYG{p}{:}
						\PYG{n}{line} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
					\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}
						\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
						\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{k}{continue}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{k}{break}
				\PYG{k}{if} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Process data read timeout!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
					\PYG{k}{break}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}term:\PYGZdq{}} \PYG{o}{+} \PYG{n}{line}\PYG{o}{.}\PYG{n}{rstrip}\PYG{p}{()}
			\PYG{k}{if} \PYG{n}{line} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{:}
				\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
		\PYG{k}{return} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{clear\PYGZus{}messages}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Empty messages that have come through socket connection}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
		\PYG{k}{try}\PYG{p}{:}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}
		\PYG{k}{except} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{error}\PYG{p}{:}				\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
			\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
			\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
				\PYG{k}{try}\PYG{p}{:}
					\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{recv}\PYG{p}{(}\PYG{l+m+mi}{1024}\PYG{p}{)}
				\PYG{k}{except} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{error}\PYG{p}{:}
					\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
					\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
					\PYG{k}{continue}
				\PYG{k}{else}\PYG{p}{:}
					\PYG{k}{break}

	\PYG{k}{def} \PYG{n+nf}{clear\PYGZus{}replies}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Clear process replies}
\PYG{l+s+sd}{			Flush the stdout and read \PYGZam{} discard messages during read\PYGZus{}timeout.}
\PYG{l+s+sd}{			Additionally, empty the reply\PYGZus{}buffer}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{flush}\PYG{p}{()}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
		\PYG{k}{try}\PYG{p}{:}
			\PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
		\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}						\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
			\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
			\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
				\PYG{k}{try}\PYG{p}{:}
					\PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
				\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}
					\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
					\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
					\PYG{k}{continue}
				\PYG{k}{else}\PYG{p}{:}
					\PYG{k}{break}

	\PYG{k}{def} \PYG{n+nf}{clear\PYGZus{}stored\PYGZus{}messages}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Empty the reply\PYGZus{}buffer of messages received from the program}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contains}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read messages from the standard output/socket}
\PYG{l+s+sd}{			Verify that the specified message is received.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}receive}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contains\PYGZus{}not}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read messages from the standard output/socket}
\PYG{l+s+sd}{			Verify that the specified message isn\PYGZsq{}t received.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}receive}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not supposed to be found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contained}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Verify if a specified message is contained in the reply\PYGZus{}buffer class variable}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the recent process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contained\PYGZus{}not}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Verify that a specified message is not contained in the reply\PYGZus{}buffer class variable}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not supposed to be found in the recent process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{wait\PYGZus{}until\PYGZus{}reply\PYGZus{}contains}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	Wait until a specified reply is received}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}receive}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{persistent\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{exception\PYGZus{}replies}\PYG{p}{,}
						\PYG{n}{end\PYGZus{}reply}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Sends a command persistently until either time runs out or a certain reply is received}
\PYG{l+s+sd}{			The exception replies are such replies which are considered to be failures in the}
\PYG{l+s+sd}{			commanding of the system. When such a reply is encountered, the command is re\PYGZhy{}sent.}
\PYG{l+s+sd}{			An end reply indicates a reply which tells us to stop sending resending the command.}
\PYG{l+s+sd}{ 		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{error\PYGZus{}found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{command} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}communicate}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{exception\PYGZus{}replies} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}replies}\PYG{p}{)}
		\PYG{n}{exception\PYGZus{}replies} \PYG{o}{=} \PYG{n}{exception\PYGZus{}replies}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{};\PYGZsq{}}\PYG{p}{)}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}receive}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
				\PYG{k}{for} \PYG{n}{exception\PYGZus{}reply} \PYG{o+ow}{in} \PYG{n}{exception\PYGZus{}replies}\PYG{p}{:}
					\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
						\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Exception }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ found, retrying to send command\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)}
						\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}communicate}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
						\PYG{k}{break}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
				\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{):}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Desired reply }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was found in process replies\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}Timeout\PYGZdq{}}\PYG{p}{:}
					\PYG{k}{pass}
				\PYG{k}{else}\PYG{p}{:}
					\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Desired reply }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in process replies\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{))}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{):}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{\PYGZus{}receive}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
					\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
						\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Exception }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ still found after timeout\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{))}
\end{Verbatim}
