\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{socket}
\PYG{k+kn}{import} \PYG{n+nn}{sys}
\PYG{k+kn}{import} \PYG{n+nn}{os}
\PYG{k+kn}{import} \PYG{n+nn}{signal}
\PYG{k+kn}{import} \PYG{n+nn}{binascii}
\PYG{k+kn}{import} \PYG{n+nn}{math}
\PYG{k+kn}{import} \PYG{n+nn}{subprocess}
\PYG{k+kn}{import} \PYG{n+nn}{thread}
\PYG{k+kn}{import} \PYG{n+nn}{time}		\PYG{c+c1}{\PYGZsh{} For time stamps}
\PYG{k+kn}{import} \PYG{n+nn}{robot}
\PYG{k+kn}{from} \PYG{n+nn}{time} \PYG{k+kn}{import} \PYG{n}{sleep}
\PYG{k+kn}{from} \PYG{n+nn}{fcntl} \PYG{k+kn}{import} \PYG{n}{fcntl}\PYG{p}{,} \PYG{n}{F\PYGZus{}GETFL}\PYG{p}{,} \PYG{n}{F\PYGZus{}SETFL}
\PYG{k+kn}{from} \PYG{n+nn}{os} \PYG{k+kn}{import} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{,} \PYG{n}{read}
\PYG{k+kn}{from} \PYG{n+nn}{ConfigParser} \PYG{k+kn}{import} \PYG{n}{SafeConfigParser}
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pyplot} \PYG{k+kn}{as} \PYG{n+nn}{plt}

\PYG{k}{class} \PYG{n+nc}{CubeSatAutomation}\PYG{p}{:}
	\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Implement cleaned version and verify its operation with some linux programs and with csp client.}
\PYG{l+s+sd}{		Use some QWeb stuff.}
\PYG{l+s+sd}{	\PYGZsq{}\PYGZsq{}\PYGZsq{}}

	\PYG{c+c1}{\PYGZsh{} Only one instance of the class for all test cases}

	\PYG{n}{ROBOT\PYGZus{}LIBRARY\PYGZus{}SCOPE} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}TEST\PYGZus{}SUITE\PYGZsq{}}
	\PYG{n}{proc} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{server} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{port} \PYG{o}{=} \PYG{l+m+mi}{0}
	\PYG{n}{sock} \PYG{o}{=} \PYG{n+nb+bp}{None}
	\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{False}
	\PYG{n}{writing\PYGZus{}done} \PYG{o}{=} \PYG{n+nb+bp}{False}
	\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
	\PYG{n}{operation\PYGZus{}timer} \PYG{o}{=} \PYG{l+m+mi}{0}

	\PYG{k}{def} \PYG{n+nf+fm}{\PYGZus{}\PYGZus{}init\PYGZus{}\PYGZus{}}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser} \PYG{o}{=} \PYG{n}{SafeConfigParser}\PYG{p}{()}

	\PYG{k}{def} \PYG{n+nf}{connect\PYGZus{}socket}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{config\PYGZus{}file}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{server}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{port}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	ADD DOCUMENTATION}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}

		\PYG{k}{if} \PYG{n}{config\PYGZus{}file}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{))}
		\PYG{k}{if} \PYG{n}{server} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{server} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}SOCKET\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}server\PYGZsq{}}\PYG{p}{)}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Read:\PYGZdq{}}
			\PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{server}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{server} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{server}\PYG{p}{)}
		\PYG{k}{if} \PYG{n}{port} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}SOCKET\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}port\PYGZsq{}}\PYG{p}{)}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Read:\PYGZdq{}}
			\PYG{k}{print} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{port}\PYG{p}{)}
		\PYG{c+c1}{\PYGZsh{}self.sock = socket.socket(socket.AF\PYGZus{}INET, socket.SOCK\PYGZus{}STREAM)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock} \PYG{o}{=} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{socket}\PYG{p}{(}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{AF\PYGZus{}INET}\PYG{p}{,} \PYG{n}{socket}\PYG{o}{.}\PYG{n}{SOCK\PYGZus{}STREAM}\PYG{p}{)}
		\PYG{n}{server\PYGZus{}address} \PYG{o}{=} \PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{server}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{port}\PYG{p}{))}
		\PYG{k}{print} \PYG{l+s+s1}{\PYGZsq{}connecting to }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{ port }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{server\PYGZus{}address}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{n}{server\PYGZus{}address}\PYG{p}{)}
		\PYG{k}{print} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}

	\PYG{c+c1}{\PYGZsh{} Kaikki None aikasemmin ja esim if config\PYGZus{}file is None:\PYGZsq{}}
	\PYG{c+c1}{\PYGZsh{}		self.parser.read(\PYGZsq{}s100\PYGZus{}config.cfg\PYGZsq{})}
	\PYG{c+c1}{\PYGZsh{}	else:}
	\PYG{c+c1}{\PYGZsh{}		self.parser.read(str(config\PYGZus{}file))\PYGZsq{}}
	\PYG{k}{def} \PYG{n+nf}{client\PYGZus{}start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{config\PYGZus{}file}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{prog}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{,} \PYG{n}{params}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} ADD DOCUMENTATION}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}

		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{):}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}None in config file\PYGZdq{}}
			\PYG{k}{pass}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{config\PYGZus{}file}\PYG{p}{))}
		\PYG{k}{if} \PYG{n}{prog} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
			\PYG{n}{prog} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}PROGRAM\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}path\PYGZsq{}}\PYG{p}{)}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Read:\PYGZdq{}}
			\PYG{k}{print} \PYG{n}{prog}
		\PYG{k}{elif} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{):}
			\PYG{n}{prog} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Prog\PYGZdq{}} \PYG{o+ow}{is} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
			\PYG{n}{prog} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)}
		\PYG{k}{if} \PYG{n}{params} \PYG{o+ow}{is} \PYG{n+nb+bp}{None}\PYG{p}{:}
			\PYG{n}{params} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{parser}\PYG{o}{.}\PYG{n}{get}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}PROGRAM\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}params\PYGZsq{}}\PYG{p}{)}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Read:\PYGZdq{}}
			\PYG{k}{print} \PYG{n}{params}
		\PYG{k}{elif} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{):}
			 \PYG{n}{params} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{n}{params} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc} \PYG{o}{=} \PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{Popen}\PYG{p}{([}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{prog}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)],} \PYG{n}{stdin}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{PIPE}\PYG{p}{,}
			\PYG{n}{stdout}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{PIPE}\PYG{p}{,} \PYG{n}{stderr}\PYG{o}{=}\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{STDOUT}\PYG{p}{,} \PYG{n}{shell}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
		\PYG{n}{flags} \PYG{o}{=} \PYG{n}{fcntl}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{,} \PYG{n}{F\PYGZus{}GETFL}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} get current p.stdout flags}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}fcntl flags:\PYGZdq{}}
		\PYG{k}{print} \PYG{n}{flags}
		\PYG{n}{fcntl}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{p}{,} \PYG{n}{F\PYGZus{}SETFL}\PYG{p}{,} \PYG{n}{flags} \PYG{o}{|} \PYG{n}{O\PYGZus{}NONBLOCK}\PYG{p}{)}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Started process \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{proc}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{} with parameters \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{params}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{client\PYGZus{}close}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{prog}\PYG{p}{,} \PYG{n}{socket\PYGZus{}comm}\PYG{o}{=}\PYG{n+nb+bp}{None}\PYG{p}{):}
		\PYG{k}{if} \PYG{n}{socket\PYGZus{}comm}\PYG{p}{:}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{shutdown}\PYG{p}{(}\PYG{n}{socket}\PYG{o}{.}\PYG{n}{SHUT\PYGZus{}RDWR}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}			\PYG{c+c1}{\PYGZsh{}CubesatAutomation.sock to be sure?}
		\PYG{k}{if} \PYG{n}{prog}\PYG{p}{:}
						\PYG{n}{subprocess}\PYG{o}{.}\PYG{n}{Popen}\PYG{p}{([}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{kill\PYGZus{}command}\PYG{p}{)],} \PYG{n}{shell}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
		\PYG{k}{else}\PYG{p}{:}
			\PYG{k}{raise} \PYG{n+ne}{OSError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Program to be closed must be defined!\PYGZdq{}}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{monitor\PYGZus{}start}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Start a terminal window and send the keywords, commands and replies to there.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k}{pass}

	\PYG{k}{def} \PYG{n+nf}{send\PYGZus{}message}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Sending message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ to socket\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{message}
		\PYG{n}{message} \PYG{o}{=} \PYG{n}{message} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s2}{\PYGZdq{}}
		\PYG{k}{try}\PYG{p}{:}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{sock}\PYG{o}{.}\PYG{n}{sendall}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)}
		\PYG{k}{except}\PYG{p}{:}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Failed to send message to socket, trying to write message to stdin\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{message}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
			\PYG{k}{except}\PYG{p}{:}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Failed to write message to stdin, trying to simulate keyboard pressing\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{message}
				\PYG{k+kn}{import} \PYG{n+nn}{pyautogui}
				\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{typewrite}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
				\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{press}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}enter\PYGZsq{}}\PYG{p}{)}
		\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{send\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{send\PYGZus{}message}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Console lines\PYGZdq{}}
			\PYG{k}{print} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}error \PYGZhy{}1\PYGZdq{}} \PYG{o+ow}{in} \PYG{n}{line} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}error \PYGZhy{}2\PYGZdq{}} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n}{line}\PYG{p}{)}


	\PYG{k}{def} \PYG{n+nf}{write\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{n}{command} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Console lines\PYGZdq{}}
			\PYG{k}{print} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}

	\PYG{k}{def} \PYG{n+nf}{type\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{}	pyautogui is needed. Some solution without it?}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{k+kn}{import} \PYG{n+nn}{pyautogui}
		\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{typewrite}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}
		\PYG{n}{pyautogui}\PYG{o}{.}\PYG{n}{press}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}enter\PYGZsq{}}\PYG{p}{)}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Store\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Console lines\PYGZdq{}}
			\PYG{k}{print} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}

	\PYG{k}{def} \PYG{n+nf}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[]}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} Wait for data to be \PYGZsq{}cooked\PYGZsq{}}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{line} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
			\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}	\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
				\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Waiting for more data from process..}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
				\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
				\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{k}{try}\PYG{p}{:}
						\PYG{n}{line} \PYG{o}{=} \PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
					\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}
						\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
						\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{k}{continue}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{k}{break}
				\PYG{k}{if} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Process data read timeout!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
					\PYG{k}{break}
			\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}term:\PYGZdq{}} \PYG{o}{+} \PYG{n}{line}\PYG{o}{.}\PYG{n}{rstrip}\PYG{p}{()}
			\PYG{k}{if} \PYG{l+s+s1}{\PYGZsq{}exit\PYGZus{}client\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{os}\PYG{o}{.}\PYG{n}{killpg}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getpgid}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{pid}\PYG{p}{),} \PYG{n}{signal}\PYG{o}{.}\PYG{n}{SIGTERM}\PYG{p}{)}
				\PYG{k}{break}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{k}{if} \PYG{n}{line} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{p}{:}
					\PYG{n}{console\PYGZus{}lines}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
		\PYG{n}{console\PYGZus{}lines\PYGZus{}str} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines\PYGZus{}str}\PYG{p}{)}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} Why doesn\PYGZsq{}t return this? Because of the join?}
		\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
		\PYG{k}{return} \PYG{n}{console\PYGZus{}lines}

	\PYG{k}{def} \PYG{n+nf}{clear\PYGZus{}replies}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{option}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Clear process replies with flush command}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{flush}\PYG{p}{()}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{)} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}All\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}Stored\PYGZdq{}} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{option}\PYG{p}{):}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
			\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}	\PYG{c+c1}{\PYGZsh{} No data to be read, wait if more comes}
				\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{l+m+mi}{0}
				\PYG{k}{while} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
					\PYG{k}{try}\PYG{p}{:}
						\PYG{n}{read}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdout}\PYG{o}{.}\PYG{n}{fileno}\PYG{p}{(),} \PYG{l+m+mi}{1024}\PYG{p}{)}
					\PYG{k}{except} \PYG{n+ne}{OSError}\PYG{p}{:}
						\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
						\PYG{n}{read\PYGZus{}timecount} \PYG{o}{=} \PYG{n}{read\PYGZus{}timecount} \PYG{o}{+} \PYG{l+m+mi}{1}
						\PYG{k}{continue}
					\PYG{k}{else}\PYG{p}{:}
						\PYG{k}{break}


	\PYG{k}{def} \PYG{n+nf}{store\PYGZus{}client\PYGZus{}responses\PYGZus{}thread}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}	Write the responses to a file.}
\PYG{l+s+sd}{	   		Thus we can keep track of what we have done with the satellite.}
\PYG{l+s+sd}{	   		Various verify\PYGZus{}result keywords parse the responses and fail the cases accordingly.}
\PYG{l+s+sd}{	   		Use the Queue module to send information to thread(s) that it is okay to read now.}
\PYG{l+s+sd}{	   		Or some threading. Queue as a class variable? Or just with a class variable?}
\PYG{l+s+sd}{	   		Close this if after few loops we get nothing.}
\PYG{l+s+sd}{		\PYGZdq{}\PYGZdq{}\PYGZdq{}}
		\PYG{c+c1}{\PYGZsh{}CubeSatAutomation.read\PYGZus{}queue = Queue.Queue()}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZlt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o+ow}{is} \PYG{n+nb+bp}{False}\PYG{p}{:}
				\PYG{k}{try}\PYG{p}{:}
					\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{),} \PYG{l+s+s1}{\PYGZsq{}a\PYGZsq{}}\PYG{p}{)}	\PYG{c+c1}{\PYGZsh{} Creates a new file if the old one was moved already}
				\PYG{k}{except} \PYG{n+ne}{IOError}\PYG{p}{:}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Storing couldn\PYGZsq{}t open }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
					\PYG{k}{raise} \PYG{n+ne}{IOError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Couldn\PYGZsq{}t open }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{))}
				\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{p}{[]}
				\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
				\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{)}
				\PYG{n}{f}\PYG{o}{.}\PYG{n}{writelines}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}
				\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{True}	\PYG{c+c1}{\PYGZsh{} Lock the file, implement a proper lock}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
				\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing\PYGZus{}done} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{False}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing\PYGZus{}done} \PYG{o}{=} \PYG{n+nb+bp}{False}
				\PYG{k}{break}
		\PYG{c+c1}{\PYGZsh{} SVA style solution, write some end of test indicator to the file and the verifying keyword polls for that?}
		\PYG{c+c1}{\PYGZsh{} Add time to the filename}
			\PYG{c+c1}{\PYGZsh{}sys.exit()}
		\PYG{c+c1}{\PYGZsh{} Write beginning time and end time to the file}

	\PYG{k}{def} \PYG{n+nf}{store\PYGZus{}client\PYGZus{}responses}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{):}
		\PYG{n}{thread}\PYG{o}{.}\PYG{n}{start\PYGZus{}new\PYGZus{}thread}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{store\PYGZus{}client\PYGZus{}responses\PYGZus{}thread}\PYG{p}{,} \PYG{p}{(}\PYG{n}{filename}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}message}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Read messages from the process stdout and verify if the desired text exists.}
\PYG{l+s+sd}{		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contains}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{verify\PYGZus{}reply\PYGZus{}message}\PYG{p}{(}\PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contains\PYGZus{}not}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{):}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{),} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not supposed to be found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contained}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the recent process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}reply\PYGZus{}contained\PYGZus{}not}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{):}
		\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
		\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not supposed to be found in the recent process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{wait\PYGZus{}until\PYGZus{}reply\PYGZus{}contains}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer}\PYG{p}{:}
			\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
		\PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{found}\PYG{p}{:}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{wait\PYGZus{}until\PYGZus{}reply\PYGZus{}contains\PYGZus{}not}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{):}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{)}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{k}{print} \PYG{n}{time\PYGZus{}count}
			\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}found, not finished\PYGZdq{}}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
					\PYG{k}{break}
		\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{k}{print} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was found in the process replies until timeout!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{verify\PYGZus{}stored\PYGZus{}reply\PYGZus{}message}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{filename}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{):}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Time count is larger? \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{time\PYGZus{}count}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{} \PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{)}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{False}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing\PYGZus{}done} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
			\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o+ow}{is} \PYG{n+nb+bp}{True}\PYG{p}{:}
				\PYG{k}{try}\PYG{p}{:}
					\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{),} \PYG{l+s+s1}{\PYGZsq{}r\PYGZsq{}}\PYG{p}{)}
				\PYG{k}{except} \PYG{n+ne}{IOError}\PYG{p}{:}
					\PYG{k}{raise} \PYG{n+ne}{IOError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Couldn\PYGZsq{}t open }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{))}
				\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{()}
				\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
					\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
						\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
						\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{False}
						\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing\PYGZus{}done} \PYG{o}{=} \PYG{n+nb+bp}{True}
						\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
						\PYG{k}{break}
				\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{writing} \PYG{o}{=} \PYG{n+nb+bp}{False}	\PYG{c+c1}{\PYGZsh{} Free the file}
				\PYG{c+c1}{\PYGZsh{}CubeSatAutomation.writing\PYGZus{}done = True}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{k}{continue}
		\PYG{c+c1}{\PYGZsh{} Move the file storing to another keyword, but we want to store the failed ones as well}
		\PYG{k}{if} \PYG{n}{completed}\PYG{p}{:}
			\PYG{k}{try}\PYG{p}{:}
				\PYG{n}{f} \PYG{o}{=} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{),} \PYG{l+s+s1}{\PYGZsq{}r\PYGZsq{}}\PYG{p}{)}
			\PYG{k}{except} \PYG{n+ne}{IOError}\PYG{p}{:}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Verifying couldn\PYGZsq{}t open }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n}{f}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{()}
		\PYG{n}{f}\PYG{o}{.}\PYG{n}{close}\PYG{p}{()}
		\PYG{c+c1}{\PYGZsh{} Rename and move file}
		\PYG{n}{new\PYGZus{}filename} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{())} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}/satellite\PYGZus{}passes/\PYGZdq{}}  \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s2}{\PYGZdq{}\PYGZus{}\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{time}\PYG{o}{.}\PYG{n}{time}\PYG{p}{())}	\PYG{c+c1}{\PYGZsh{} Unix time}
		\PYG{n}{os}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{filename}\PYG{p}{),} \PYG{n}{new\PYGZus{}filename}\PYG{p}{)}
		\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
			\PYG{k}{raise} \PYG{n+ne}{ValueError}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Message }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in the stored process replies!}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{))}


	\PYG{k}{def} \PYG{n+nf}{wait\PYGZus{}and\PYGZus{}notify}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{event}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{soundfile}\PYG{p}{):}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{k}{break}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{c+c1}{\PYGZsh{} Play some sound signal when time is reached}
		\PYG{n}{cwd} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{()}
		\PYG{n}{path} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cwd}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soundfile}\PYG{p}{)}
		\PYG{k+kn}{from} \PYG{n+nn}{playsound} \PYG{k+kn}{import} \PYG{n}{playsound}
		\PYG{n}{playsound}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{notify\PYGZus{}after\PYGZus{}thread}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{event}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{soundfile}\PYG{p}{):}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{k}{break}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{operation\PYGZus{}timer} \PYG{o}{=} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{operation\PYGZus{}timer} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{c+c1}{\PYGZsh{} Play some sound signal when time is reached}
		\PYG{n}{cwd} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{getcwd}\PYG{p}{()}
		\PYG{n}{path} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{cwd}\PYG{p}{)} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{soundfile}\PYG{p}{)}
		\PYG{k+kn}{from} \PYG{n+nn}{playsound} \PYG{k+kn}{import} \PYG{n}{playsound}
		\PYG{n}{playsound}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}

	\PYG{k}{def} \PYG{n+nf}{notify\PYGZus{}after}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{event}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{soundfile}\PYG{p}{):}
		\PYG{n}{thread}\PYG{o}{.}\PYG{n}{start\PYGZus{}new\PYGZus{}thread}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{notify\PYGZus{}after\PYGZus{}thread}\PYG{p}{,} \PYG{p}{(}\PYG{n}{event}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{,} \PYG{n}{soundfile}\PYG{p}{))}

	\PYG{k}{def} \PYG{n+nf}{wait\PYGZus{}until\PYGZus{}time\PYGZus{}event}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{event}\PYG{p}{,} \PYG{n}{timeout}\PYG{p}{):}
		\PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{operation\PYGZus{}timer} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Timed event }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ reached\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{event}\PYG{p}{)}
				\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{operation\PYGZus{}timer} \PYG{o}{=} \PYG{l+m+mi}{0}
				\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{20}\PYG{p}{)} 	\PYG{c+c1}{\PYGZsh{} Average time for the notification sound to play}
				\PYG{k}{break}

	\PYG{k}{def} \PYG{n+nf}{persistent\PYGZus{}command}\PYG{p}{(}\PYG{n+nb+bp}{self}\PYG{p}{,} \PYG{n}{message}\PYG{p}{,} \PYG{n}{exception\PYGZus{}replies}\PYG{p}{,} \PYG{n}{end\PYGZus{}reply}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}}\PYG{p}{,} \PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,} \PYG{n}{read\PYGZus{}timeout}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{):}
		\PYG{l+s+sd}{\PYGZsq{}\PYGZsq{}\PYGZsq{} Sends a command persistently until either time runs out or a certain reply is received}
\PYG{l+s+sd}{ 		\PYGZsq{}\PYGZsq{}\PYGZsq{}}
		\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{l+m+mi}{0}
		\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{error\PYGZus{}found} \PYG{o}{=} \PYG{n+nb+bp}{False}
		\PYG{n}{command} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{message}\PYG{p}{)} \PYG{o}{+} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}r}\PYG{l+s+s1}{\PYGZsq{}}
		\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
		\PYG{n}{exception\PYGZus{}replies} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}replies}\PYG{p}{)}
		\PYG{n}{exception\PYGZus{}replies} \PYG{o}{=} \PYG{n}{exception\PYGZus{}replies}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{};\PYGZsq{}}\PYG{p}{)}
		\PYG{k}{print} \PYG{n}{exception\PYGZus{}replies}
		\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{completed}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{time\PYGZus{}count} \PYG{o}{\PYGZgt{}=} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{timeout}\PYG{p}{):}
				\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
				\PYG{k}{break}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
				\PYG{k}{for} \PYG{n}{exception\PYGZus{}reply} \PYG{o+ow}{in} \PYG{n}{exception\PYGZus{}replies}\PYG{p}{:}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}exception\PYGZus{}reply:\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}reply line:\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
					\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
						\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Exception }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ found, retrying to send command\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)}
						\PYG{c+c1}{\PYGZsh{}error\PYGZus{}found = True}
						\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{proc}\PYG{o}{.}\PYG{n}{stdin}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}
						\PYG{k}{break}
				\PYG{c+c1}{\PYGZsh{} if len(end\PYGZus{}reply) \PYGZgt{} 1:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
				\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{):}
					\PYG{n}{completed} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{n}{found} \PYG{o}{=} \PYG{n+nb+bp}{True}
					\PYG{k}{break}
			\PYG{n}{time\PYGZus{}count} \PYG{o}{=} \PYG{n}{time\PYGZus{}count} \PYG{o}{+} \PYG{l+m+mi}{1}
			\PYG{n}{time}\PYG{o}{.}\PYG{n}{sleep}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}
		\PYG{k}{if} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{1}\PYG{p}{:}
			\PYG{k}{if} \PYG{n}{found}\PYG{p}{:}
				\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}Desired reply }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was found in process replies\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)}
			\PYG{k}{else}\PYG{p}{:}
				\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}Timeout\PYGZdq{}}\PYG{p}{:}
					\PYG{k}{pass}
				\PYG{k}{else}\PYG{p}{:}
					\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Desired reply }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ was not found in process replies\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{))}
		\PYG{k}{if} \PYG{l+s+s2}{\PYGZdq{}None\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{or} \PYG{l+s+s2}{\PYGZdq{}Timeout\PYGZdq{}} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{end\PYGZus{}reply}\PYG{p}{):}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb+bp}{self}\PYG{o}{.}\PYG{n}{read\PYGZus{}console\PYGZus{}reply}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{read\PYGZus{}timeout}\PYG{p}{))}
			\PYG{n}{console\PYGZus{}lines} \PYG{o}{=} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{console\PYGZus{}lines}\PYG{p}{)}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZbs{}}\PYG{l+s+s2}{n\PYGZdq{}}\PYG{p}{)}
			\PYG{n}{CubeSatAutomation}\PYG{o}{.}\PYG{n}{reply\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{console\PYGZus{}lines}
			\PYG{k}{for} \PYG{n}{line} \PYG{o+ow}{in} \PYG{n}{console\PYGZus{}lines}\PYG{p}{:}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}exception\PYGZus{}reply:\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)}
					\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}reply line:\PYGZdq{}} \PYG{o}{+} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
					\PYG{k}{if} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{)} \PYG{o+ow}{in} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{line}\PYG{p}{):}
						\PYG{k}{raise} \PYG{n+ne}{ValueError} \PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}Exception }\PYG{l+s+si}{\PYGZpc{}s}\PYG{l+s+s2}{ still found after timeout\PYGZdq{}} \PYG{o}{\PYGZpc{}} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{exception\PYGZus{}reply}\PYG{p}{))}
\end{Verbatim}
